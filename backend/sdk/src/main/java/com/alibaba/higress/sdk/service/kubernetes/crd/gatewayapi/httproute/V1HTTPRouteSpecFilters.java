/*
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.21.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.alibaba.higress.sdk.service.kubernetes.crd.gatewayapi.httproute;

import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.io.IOException;
import java.util.Objects;

/**
 * HTTPRouteFilter defines processing steps that must be completed during the request or response lifecycle. HTTPRouteFilters are meant as an extension point to express processing that may be done in Gateway implementations. Some examples include request or response modification, implementing authentication strategies, rate-limiting, and traffic shaping. API guarantee/conformance is defined based on the type of the filter.
 */
@Data
public class V1HTTPRouteSpecFilters {
  public static final String SERIALIZED_NAME_EXTENSION_REF = "extensionRef";
  @SerializedName(SERIALIZED_NAME_EXTENSION_REF)
  private V1HTTPRouteSpecExtensionRef extensionRef;


  public static final String SERIALIZED_NAME_REQUEST_HEADER_MODIFIER = "requestHeaderModifier";
  @SerializedName(SERIALIZED_NAME_REQUEST_HEADER_MODIFIER)
  private V1HTTPRouteSpecRequestHeaderModifier requestHeaderModifier;

  public static final String SERIALIZED_NAME_REQUEST_MIRROR = "requestMirror";
  @SerializedName(SERIALIZED_NAME_REQUEST_MIRROR)
  private V1HTTPRouteSpecRequestMirror requestMirror;

  public static final String SERIALIZED_NAME_REQUEST_REDIRECT = "requestRedirect";
  @SerializedName(SERIALIZED_NAME_REQUEST_REDIRECT)
  private V1HTTPRouteSpecRequestRedirect requestRedirect;

  public static final String SERIALIZED_NAME_RESPONSE_HEADER_MODIFIER = "responseHeaderModifier";
  @SerializedName(SERIALIZED_NAME_RESPONSE_HEADER_MODIFIER)
  private V1HTTPRouteSpecResponseHeaderModifier responseHeaderModifier;

  /**
   * Type identifies the type of filter to apply. As with other API fields, types are classified into three conformance levels:   - Core: Filter types and their corresponding configuration defined by   \&quot;Support: Core\&quot; in this package, e.g. \&quot;RequestHeaderModifier\&quot;. All   implementations must support core filters.   - Extended: Filter types and their corresponding configuration defined by   \&quot;Support: Extended\&quot; in this package, e.g. \&quot;RequestMirror\&quot;. Implementers   are encouraged to support extended filters.   - Implementation-specific: Filters that are defined and supported by   specific vendors.   In the future, filters showing convergence in behavior across multiple   implementations will be considered for inclusion in extended or core   conformance levels. Filter-specific configuration for such filters   is specified using the ExtensionRef field. &#x60;Type&#x60; should be set to   \&quot;ExtensionRef\&quot; for custom filters.   Implementers are encouraged to define custom implementation types to extend the core API with implementation-specific behavior.   If a reference to a custom filter type cannot be resolved, the filter MUST NOT be skipped. Instead, requests that would have been processed by that filter MUST receive a HTTP error response.   Note that values may be added to this enum, implementations must ensure that unknown values will not cause a crash.   Unknown values here must result in the implementation setting the Accepted Condition for the Route to &#x60;status: False&#x60;, with a Reason of &#x60;UnsupportedValue&#x60;.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    REQUESTHEADERMODIFIER("RequestHeaderModifier"),
    
    RESPONSEHEADERMODIFIER("ResponseHeaderModifier"),
    
    REQUESTMIRROR("RequestMirror"),
    
    REQUESTREDIRECT("RequestRedirect"),
    
    URLREWRITE("URLRewrite"),
    
    EXTENSIONREF("ExtensionRef");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return TypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TypeEnum type;

  public static final String SERIALIZED_NAME_URL_REWRITE = "urlRewrite";
  @SerializedName(SERIALIZED_NAME_URL_REWRITE)
  private V1HTTPRouteSpecUrlRewrite urlRewrite;



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1HTTPRouteSpecFilters v1HTTPRouteSpecFilters = (V1HTTPRouteSpecFilters) o;
    return Objects.equals(this.extensionRef, v1HTTPRouteSpecFilters.extensionRef) &&
        Objects.equals(this.requestHeaderModifier, v1HTTPRouteSpecFilters.requestHeaderModifier) &&
        Objects.equals(this.requestMirror, v1HTTPRouteSpecFilters.requestMirror) &&
        Objects.equals(this.requestRedirect, v1HTTPRouteSpecFilters.requestRedirect) &&
        Objects.equals(this.responseHeaderModifier, v1HTTPRouteSpecFilters.responseHeaderModifier) &&
        Objects.equals(this.type, v1HTTPRouteSpecFilters.type) &&
        Objects.equals(this.urlRewrite, v1HTTPRouteSpecFilters.urlRewrite);
  }

  @Override
  public int hashCode() {
    return Objects.hash(extensionRef, requestHeaderModifier, requestMirror, requestRedirect, responseHeaderModifier, type, urlRewrite);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1HTTPRouteSpecFilters {\n");
    sb.append("    extensionRef: ").append(toIndentedString(extensionRef)).append("\n");
    sb.append("    requestHeaderModifier: ").append(toIndentedString(requestHeaderModifier)).append("\n");
    sb.append("    requestMirror: ").append(toIndentedString(requestMirror)).append("\n");
    sb.append("    requestRedirect: ").append(toIndentedString(requestRedirect)).append("\n");
    sb.append("    responseHeaderModifier: ").append(toIndentedString(responseHeaderModifier)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    urlRewrite: ").append(toIndentedString(urlRewrite)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

